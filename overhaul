#!/usr/bin/env python
import math
from math import atan2, degrees
import rospy
import time
from geometry_msgs.msg import Twist
import numpy as np
from nav_msgs.msg import Odometry
from sensor_msgs.msg import LaserScan
import sys
import signal
import message_filters #this is what should allow a single callback on multiple messages.
from tf.transformations import euler_from_quaternion, quaternion_from_euler
from std_msgs.msg import String
from robot import Robot, Spot
object_ahead = bool(False)
heading_north = bool(False)
heading_fixed = bool(False)
ranges = []
robot_ahead = bool(False)
roll = pitch = yaw = 0.0
orders = " "
Ready = bool(False)
assigned = bool(False)
right = bool(False)
TargetX = float(0)
TargetY = float(0)
R1 = Robot(0, 0, 0, 0, 0)
R2 = Robot(0, 0, 0, 0, 0)
R3 = Robot(0, 0, 0, 0, 0)
R4 = Robot(0, 0, 0, 0, 0)
R5 = Robot(0, 0, 0, 0, 0)
R6 = Robot(0, 0, 0, 0, 0)
R7 = Robot(0, 0, 0, 0, 0)
S1 = Spot(0, 0, 1)
S2 = Spot(0, 0, 2)
S3 = Spot(0, 0, 3)
S4 = Spot(0, 0, 4)
S5 = Spot(0, 0, 5)
S6 = Spot(0, 0, 6)
S7 = Spot(0, 0, 7)
all_robots = [R1, R2, R3, R4, R5, R6, R7]
all_spots = [S1, S2, S3, S4, S5, S6, S7]

def update_orders(msg):
	global orders
	orders = msg.data
	print(orders)

def check_robots(R1_pose, R2_pose, R3_pose, R4_pose, R5_pose, R6_pose, R7_pose):
	global roll, pitch, yaw
	global robot_ahead
	robot_ahead = False
	orientation_q = msg.pose.pose.orientation
	orientation_list = [orientation_q.x, orientation_q.y, orientation_q.z, orientation_q.w]
	(roll, pitch, yaw) = euler_from_quaternion (orientation_list)
	MyHeading = yaw
	MyX = float(R1_pose.pose.pose.position.x)
	MyY = float(R1_pose.pose.pose.position.y)
	R2.x = float(R2_pose.pose.pose.position.x)
	R2.y = float(R2_pose.pose.pose.position.y)
	R3.x = float(R3_pose.pose.pose.position.x)
	R3.y = float(R3_pose.pose.pose.position.y)
	R4.x = float(R4_pose.pose.pose.position.x)
	R4.y = float(R4_pose.pose.pose.position.y)
	R5.x = float(R5_pose.pose.pose.position.x)
	R5.y = float(R5_pose.pose.pose.position.y)
	R6.x = float(R6_pose.pose.pose.position.x)
	R6.y = float(R6_pose.pose.pose.position.y)
	R7.x = float(R7_pose.pose.pose.position.x)
	R7.y = float(R7_pose.pose.pose.position.y)
	for item in all_robots:
		distance = math.sqrt((item.x - MyX)**2 + (item.y - MyY)**2)
		if 0 < distance < 0.75
			Xdistance = item.x - MyX
			Ydistance = item.y - MyY
			if (-0.25*np.pi) < MyHeading <= (0.75*np.pi):  # check northwest
				if Xdistance >= 0 and Ydistance >= 0:
					robot_ahead = True
			if (0.25*np.pi) < MyHeading <= (1.25*np.pi):  # check southwest
				if Xdistance <= 0 and Ydistance >= 0:
					robot_ahead = True
			if (-1.25*np.pi) < MyHeading <= (-0.25*np.pi):  # check southeast
				if Xdistance <= 0 and Ydistance <= 0:
					robot_ahead = True
			if (-0.75*np.pi) < MyHeading <= (0.25*np.pi):  # check northeast
				if Xdistance >= 0 and Ydistance <= 0:
					robot_ahead = True

def check_laser(msg):
	global object_ahead
	global ranges
	ranges = msg.ranges
	object_ahead = False
	object_ahead_distance = min(msg.ranges[0], msg.ranges[10], msg.ranges[20], msg.ranges[350], msg.ranges[340])
	if object_ahead_distance < 0.8:
		object_ahead = True
		print("object ahead")

def go(msg):
	global assigned
	global TargetX
	global TargetY
	global Ready
	global right
	if orders == "1":
		assigned = False
		in_position = False
		heading_north = False
		heading_fixed = False
		right = False
		for item in all_robots:
			item.spot = 0
		for item in all_spots:
			item.occupied = False
		move = Twist()
		move.linear.y = 0.0
		if object_ahead or if robot_ahead:
			move.linear.x = 0.0
			move.angular.z = 0.5
			pub = rospy.Publisher("/robot1/cmd_vel", Twist, queue_size=1)
			pub.publish(move)
		if not object_ahead and not robot_ahead:
			move.linear.x = 0.5
			move.angular.z = 0.0
			pub = rospy.Publisher("/robot1/cmd_vel", Twist, queue_size=1)
			pub.publish(move)
	if orders == "0":
		assigned = False
		in_position = False
		heading_north = False
		heading_fixed = False
		right = False
		for item in all_spots:
			item.occupied = False
		move = Twist()
		move.linear.x = 0.0
		move.angular.z = 0.0
		move.linear.y = 0.0
		pub = rospy.Publisher("/robot1/cmd_vel", Twist, queue_size=2)
		pub.publish(move)
	if orders == "2":
		S1.x = 0
		S1.y = 0
		S2.x = 1
		S2.y = 0
		S3.x = 2
		S3.y = 0
		S4.x = 0
		S4.y = 1
		S5.x = 1
		S5.y = 1
		S6.x = 2
		S6.y = 1
		S7.x = 0
		S7.y = 2
	if orders == "3":
		S7.x = 3
		S7.y = 3
		S5.x = 2.5
		S5.y = 2.5
		S3.x = 2.0
		S3.y = 2.0
		S1.x = 1.5
		S1.y = 1.5
		S2.x = 2.0
		S2.y = 1
		S4.x = 2.5
		S4.y = 0.5
		S6.x = 3
		S6.y = 0
	if orders == "4":
		S1.y = 0
		S1.x = 0
		S2.y = 1
		S2.x = 0
		S3.y = 2
		S3.x = 0
		S4.y = 0
		S4.x = 1
		S5.y = 1
		S5.x = 1
		S6.y = 2
		S6.x = 1
		S7.y = 0
		S7.x = 2
	if orders == "5":
		S1.x = 1.5
		S1.y = 0.5
		S2.x = 2.207
		S2.y = 0.793
		S3.x = 2.5
		S3.y = 1.5
		S4.x = 2.207
		S4.y = 2.207
		S5.x = 1.5
		S5.y = 2.5
		S6.x = 0.793
		S6.y = 2.207
		S7.x = 0.5
		S7.y = 1.5
	if orders == "2" or orders == "3" or orders == "4" or orders == "5":
		Ready = False
		if not assigned:
			move = Twist()
			move.linear.x = 0.0
			move.angular.z = 0.0
			move.linear.y = 0.0
			pub = rospy.Publisher("/robot1/cmd_vel", Twist, queue_size=2)
			pub.publish(move)
			center_x = (S1.x + S2.x + S3.x + S4.x + S5.x + S6.x + S7.x)/7
			center_y = (S1.y + S2.y + S3.y + S4.y + S5.y + S6.y + S7.y)/7
			for item in all_robots:
				item.distance = math.sqrt(((center_x - item.x)**2)+((center_y - item.y)**2))
			robot_distances = [0.0, R1.distance, R2.distance, R3.distance, R4.distance, R5.distance, R6.distance, R7.distance]
			available_spots = [S1, S2, S3, S4, S5, S6, S7]
			leader_message = "Robot 1 is the Leader"
			while not assigned:
				if max(robot_distances) == R1.distance: #if I am the furthest robot away from the formation
					robot_distances.remove(R1.distance)
					for item in available_spots:
						if item.occupied:
							available_spots.remove(item)
					check_distance = 100
					for item in available_spots:
						potential_distance = math.sqrt((item.x - R1.x)**2 + (item.y - R1.y)**2)
						if potential_distance < check_distance:
							check_distance = potential_distance
							R1.spot = item.number 
					for item in available_spots:
						if R1.spot == item.number:
							item.occupied = True
					if R1.spot == S1.number: #if I am the leader 
						print("I am the leader")
				if len(robot_distances) == 1:
					assigned = True
					break
				if max(robot_distances) == R2Dist:
					robot_distances.remove(R2Dist)
					for item in available_spots:
						if item.occupied:
							available_spots.remove(item)
					check_distance = 100
					for item in available_spots:
						potential_distance = math.sqrt((item.x - R2.x)**2 + (item.y - R2.y)**2)
						if potential_distance < check_distance:
							check_distance = potential_distance
							R2.spot = item.number 
					for item in available_spots:
						if R2.spot == item.number:
							item.occupied = True
					decision_message += " R2spot" + str(R2.spot) 
				if len(robot_distances) == 1:
					assigned = True
					break
				if max(robot_distances) == R3Dist:
					robot_distances.remove(R3Dist)
					for item in available_spots:
						if item.occupied:
							available_spots.remove(item)
					check_distance = 100
					for item in available_spots:
						potential_distance = math.sqrt((item.x - R3.x)**2 + (item.y - R3.y)**2)
						if potential_distance < check_distance:
							check_distance = potential_distance
							R3.spot = item.number 
					for item in available_spots:
						if R3.spot == item.number:
							item.occupied = True
				decision_message += " R3spot" + str(R3.spot) 
				if len(robot_distances) == 1:
					assigned = True
					break
			print(decision_message)
			pub2 = rospy.Publisher('/robot1/chatter', String, queue_size=1)
			rate = rospy.Rate(10)
			pub2.publish(decision_message)
		for item in all_spots:
			if R1.spot == item.number:  # the robot needs to point to its assigned position.
				angle = atan2(R1.y - item.y, R1.x - item.x) - np.pi
				TargetX = item.x
				TargetY = item.y
		if angle < -3.1415:
			angle += (2*np.pi)  # important line of code to make sure the angle value stays in the correct range of values
		if (angle-0.3) < R1.heading < (angle + 0.3):
			Ready = True
			move = Twist()
			move.linear.x = 0.0
			move.angular.z = 0.0
			move.linear.y = 0.0
			pub = rospy.Publisher("/robot1/cmd_vel", Twist, queue_size=2)
			pub.publish(move)
		if not Ready:
			target_distance = math.sqrt(((R1.y-TargetY)**2)+((R1.x - TargetX)**2))
			if target_distance > 0.05:
				if 0 <= R1.heading < (np.pi/2):  # get the rover to turn right in some cases, depending on its quadrant
					if (np.pi/-2) <= angle <= 0:
						right = True
				if (np.pi/-2) <= R1.heading < 0:
					if (np.pi*-1) <= angle <= (np.pi/-2):
						right = True
				if (np.pi/-1) <= R1.heading < (np.pi/-2):
					if (np.pi/2) <= angle <= np.pi:
						right = True
				if (np.pi/2) <= R1.heading < np.pi:
					if 0 <= angle <= (np.pi/2):
						right = True
				move = Twist()
				move.linear.x = 0.0
				move.angular.z = 0.5
				move.linear.y = 0.0
				if right:
					move.angular.z = -0.5
				pub = rospy.Publisher("/robot1/cmd_vel", Twist, queue_size=2)
				pub.publish(move)
				print("must face target")
			if target_distance <= 0.05:
				move = Twist()
				move.linear.x = 0.0
				move.angular.z = 0.0
				move.linear.y = 0.0
				pub = rospy.Publisher("/robot1/cmd_vel", Twist, queue_size=2)
				pub.publish(move)
				print("reached target")
		if Ready:
			print("drive ahead")
			right = False
			target_distance = math.sqrt(((R1.y-TargetY)**2)+((R1.x - TargetX)**2))
			if target_distance > 0.05 and if not in_position:
				move = Twist()
				move.linear.x = 0.5
				if robot_ahead:
					move.linear.x = 0.1
				move.angular.z = 0.0
				move.linear.y = 0.0
				pub = rospy.Publisher("/robot1/cmd_vel", Twist, queue_size=2)
				pub.publish(move)
				print(target_distance)
			if target_distance <= 0.05 and if not in_position:
				move = Twist()
				move.linear.x = 0.0
				move.angular.z = 0.0
				move.linear.y = 0.0
				pub = rospy.Publisher("/robot1/cmd_vel", Twist, queue_size=2)
				pub.publish(move)
				in_position = True
				print("reached target")
			if in_position and if not heading_north and if orders == 2:
				print("fixing heading")
				move = Twist()
				move.linear.x = 0.0
				move.linear.y = 0.0
				move.angular.z = 0.3
				if -0.05 < R1.heading < 0.05:
					move.angular.z = 0.0
					heading_fixed = True
					print("I think I'm facing North")
				pub = rospy.Publisher("/robot1/cmd_vel", Twist, queue_size=2)
				pub.publish(move)
			if heading_north:
				if R1.Spot == S3:
					heading_fixed = True
					move = Twist()
					move.linear.x = 0.0
					move.linear.y = 0.0
					if ranges[358] < ranges[0] < ranges[2] and if ranges[88] < ranges[90] < ranges[92]:
						move.angular.z = 0.1
						heading_fixed = False
					if ranges[358] > ranges[0] > ranges[2] and if ranges[88] > ranges[90] > ranges[92]:
						move.angular.z = -0.1
						heading_fixed = False
					if heading_fixed = True:
						move.angular.z = 0.0
						nav_msgs::Odometry odom;
						odom.header.stamp = current_time
						odom.header.frame_id = "odom"
						odom.pose.pose.position.x = 3.65 - ranges[0]
						odom.pose.pose.position.y = ranges[90]
						odom.pose.pose.position.z = 0.0
						odom.pose.pose.orientation.w = 0
						odom.pose.pose.orientation.x = 0
						odom.pose.pose.orientation.y = 0
						odom.pose.pose.orientation.z = 0
						odom.child_frame_id = "base_link"
						odom.twist.twist.linear.x = 0
						odom.twist.twist.linear.y = 0
						odom.twist.twist.angular.z = 0						
						pub3 = rospy.Publisher("/robot1/odom", Odometry, queue_size=1)
						pub3.publish(odom)
						print("Now I KNOW I'm facing North")
				pub = rospy.Publisher("/robot1/cmd_vel", Twist, queue_size=2)
				pub.publish(move)
				
	if orders == "6":
		assigned = False
		Ready = False
		for item in all_spots:
			item.occupied = False
		right = False
		for item in all_spots:
			if float(R1.spot) == float(item.number):  # the robot needs to point to its assigned position.
				angle = float(atan2((1.5 - item.y), (1.5 - item.x)) - np.pi)
		if angle < -3.1415:
			angle += (2*np.pi)  # important line of code to make sure the angle value stays in the correct range of values
		if (angle-0.3) < R1.heading < (angle + 0.3):
			Ready = True
		if not Ready:
			if 0 <= R1.heading < (np.pi/2):  # get the rover to turn right in some cases, depending on its quadrant
				if (np.pi/-2) <= angle <= 0:
					right = True
			if (np.pi/-2) <= R1.heading < 0:
				if (np.pi*-1) <= angle <= (np.pi/-2):
					right = True
			if (np.pi/-1) <= R1.heading < (np.pi/-2):
				if (np.pi/2) <= angle <= np.pi:
					right = True
			if (np.pi/2) <= R1.heading < np.pi:
				if 0 <= angle <= (np.pi/2):
					right = True
			move = Twist()
			move.linear.x = 0.0
			move.angular.z = 0.5
			move.linear.y = 0.0
			if right and not object_ahead:
				move.angular.z = -0.5
			pub = rospy.Publisher("/robot1/cmd_vel", Twist, queue_size=2)
			pub.publish(move)
			print("must face target")
		if Ready and not object_ahead:
			right = False
			move = Twist()
			move.linear.x = 0.5
			if robot_ahead:
				move.linear.x = 0.1
			move.angular.z = 0.0
			move.linear.y = 0.0
			pub = rospy.Publisher("/robot1/cmd_vel", Twist, queue_size=2)
			pub.publish(move)
		if object_ahead:
			move = Twist()
			move.linear.x = 0.0
			move.angular.z = 0.5
			move.linear.y = 0.0
			pub = rospy.Publisher("/robot1/cmd_vel", Twist, queue_size=2)
			pub.publish(move)


def signal_handler(signal, frame):
	move = Twist()
	move.linear.x = 0.0
	move.angular.z = 0.0
	move.linear.y = 0.0
	pub = rospy.Publisher("/robot1/cmd_vel", Twist, queue_size=2)
	pub.publish(move)
	print("exiting program")
	sys.exit(0)


def listener():
	rospy.init_node('listener')
	rospy.Subscriber("/chatter", String, update_orders)
	rospy.Subscriber("/robot1/scan", LaserScan, check_laser)
	R1_pose = message_filters.Subscriber('/robot1/odom', Odometry)
	R2_pose = message_filters.Subscriber('/robot2/odom', Odometry)
	R3_pose = message_filters.Subscriber('/robot3/odom', Odometry)
	R4_pose = message_filters.Subscriber('/robot4/odom', Odometry)
	R5_pose = message_filters.Subscriber('/robot5/odom', Odometry)
	R6_pose = message_filters.Subscriber('/robot6/odom', Odometry)
	R7_pose = message_filters.Subscriber('/robot7/odom', Odometry)
	ts1 = message_filters.TimeSynchronizer([R1_pose, R2_pose, R3_pose, R4_pose, R5_pose, R6_pose, R7_pose], 10)
	ts1.registerCallback(check_robots)
	rospy.Subscriber("/robot1/odom", Odometry, go)
	rospy.spin()


if __name__ == '__main__':
	listener()
